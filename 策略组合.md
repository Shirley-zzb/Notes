# 策略组合

采用策略设计模式，可以实现将每一条反应规则当作一条策略，并通过策略组合来实现多条规则（策略）同时实施的效果。不过，具体的实现会取决于如何定义和组合这些策略。

### 策略模式的基本概念
策略模式的核心思想是将不同的算法或操作逻辑封装到独立的策略类中，这些策略类实现了一个通用的接口或抽象基类。这样，不同的策略可以动态地互换使用，而不需要改变使用它们的代码。

### 多条反应规则相当于多条策略
在你的问题中，如果每条反应规则都封装为一个独立的策略类，那么你可以通过以下几种方式来实现多条规则（策略）同时实施：

1. **策略组合**：
   - 你可以定义一个策略组合类，该类负责存储多个策略实例，并依次调用每个策略的执行方法。这样，在某个反应场景中，你可以将多个规则组合起来，逐一执行它们。

2. **链式调用**：
   - 每个策略可以依次调用下一个策略。可以通过设计类似责任链模式的方式，使得每个策略在执行完毕后，将控制权传递给下一个策略，直到所有策略都被执行。
3. **并行执行**：
   - 如果不同策略之间是相互独立的，或者顺序无关，你也可以并行执行这些策略。比如使用多线程或异步方法来同时执行多个反应规则。

### 具体实现方式示例

1. **定义策略接口**：

```python
from abc import ABC, abstractmethod

class ReactionRule(ABC):
    @abstractmethod
    def apply(self, reactants):
        pass
```

2. **实现不同的反应规则（策略）**：

```python
class Rule1(ReactionRule):
    def apply(self, reactants):
        # 实现规则1的逻辑
        print("应用规则1")
        # 返回处理后的反应物
        return reactants

class Rule2(ReactionRule):
    def apply(self, reactants):
        # 实现规则2的逻辑
        print("应用规则2")
        return reactants
```

3. **策略组合类**：

```python
class ReactionRuleComposite:
    def __init__(self):
        self.rules = []
    
    def add_rule(self, rule):
        self.rules.append(rule)
    
    def apply_all(self, reactants):
        for rule in self.rules:
            reactants = rule.apply(reactants)
        return reactants
```

4. **使用策略组合来执行多条规则**：

```python
# 创建策略组合
composite = ReactionRuleComposite()
composite.add_rule(Rule1())
composite.add_rule(Rule2())

# 执行所有规则
reactants = {}  # 假设初始反应物
composite.apply_all(reactants)
```

### 解释：
- 每条反应规则（策略）是一个独立的类，实现 `ReactionRule` 接口。
- 策略组合类 `ReactionRuleComposite` 管理多个策略（反应规则），并通过 `apply_all` 方法来依次执行所有策略。
- 你可以灵活地添加、删除或替换不同的反应规则（策略），实现模块化、可扩展的设计。

### 扩展：多策略并行处理
如果你希望同时执行多条反应规则，而不是按顺序执行，你可以将每个策略的 `apply` 方法在不同的线程或进程中执行，这样可以实现并行的效果：

```python
import concurrent.futures

class ParallelReactionRuleComposite:
    def __init__(self):
        self.rules = []
    
    def add_rule(self, rule):
        self.rules.append(rule)
    
    def apply_all(self, reactants):
        with concurrent.futures.ThreadPoolExecutor() as executor:
            futures = [executor.submit(rule.apply, reactants) for rule in self.rules]
            for future in concurrent.futures.as_completed(futures):
                # 处理每个策略的执行结果
                reactants = future.result()
        return reactants
```

在这个例子中，策略（反应规则）会并行执行，适用于那些可以并行处理的反应规则。

### 总结
通过策略模式，每一条反应规则都可以被封装成独立的策略，然后通过组合、顺序执行或并行执行等方式来实现多个规则同时应用。根据实际需求，你可以选择合适的组合方式来设计这些策略的执行流程。